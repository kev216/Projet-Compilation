import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/* Generated By:JJTree: Do not edit this line. ASTLet.java Version 4.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class ASTLet extends SimpleNode implements Binder {
	public ASTLet(int id) {
		super(id);
	}

	public ASTLet(Parser p, int id) {
		super(p, id);
	}

	public Type getArgType() {return (Type) jjtGetChild(0);}

	public ASTTermVar getArg() {return (ASTTermVar) jjtGetChild(1);}

	public SimpleNode getFirstProcess() {return (SimpleNode) jjtGetChild(2);}

	public SimpleNode getSecondProcess() {return (SimpleNode) jjtGetChild(3);}

	public List<VarOccurrence> declaredVars() { 
		VarOccurrence occ=new VarOccurrence(getArg().getName(),getArg());
		List<VarOccurrence> l = new ArrayList<VarOccurrence>();
		l.add(occ);
		return l;
	}

	public List<Type> declaredTypes() {
		List<Type> l = new ArrayList<Type>();
		Type ty = getArgType();
		l.add(ty);
		return l;
	}


	public Type type() throws TypeException {
		ASTTermVar var = (ASTTermVar)jjtGetChild(1);
		SimpleNode t1 = getFirstProcess();
		SimpleNode t2 = getSecondProcess();
		if(!var.type().equals(t1.type()))
			throw new TypeException("La variable et le premier processus ne sont pas du même type");
		return t2.type();
	}

	public List<OOTStatement> code() throws TypeException {
		List<OOTStatement> listeRes = new ArrayList<OOTStatement>();
		String modifiers = "public";
		String name = "Let"+getArg().getLineColumn();

		//Creation des differents parametres pour creer un objet OOTClass
		List<OOTVar<? extends OOTType>> attributes = new ArrayList<OOTVar<?>>();
		List<OOTVar<? extends OOTType>> params = new ArrayList<OOTVar<?>>();
		List<OOTType> generictypes = new ArrayList<OOTType>();
		List<OOTMeth<? extends OOTType>> methods = new ArrayList<OOTMeth<?>>();
		List<OOTStatement> statements = new ArrayList<OOTStatement>();

		List<OOTExpr<?>> ListeExpr = new ArrayList<OOTExpr<?>>(); 

		//Types de reference
		ASTInt inttype = new ASTInt(Parser.JJTTYPE);
		ASTBool booltype = new ASTBool(Parser.JJTTYPE);
		ASTProc voidtype = new ASTProc(Parser.JJTTYPE);
		//ASTType proctype = new ASTType(Parser.JJTTYPE);
 
		//Liste des variables libres
		List<VarOccurrence> free = this.declaredVars();
		Iterator<VarOccurrence> itFree = free.iterator();
		int i=1;
		//System.out.println("*****************************");
		while(itFree.hasNext()) {
			OOTVar<?> ootv=null;
			VarOccurrence var = itFree.next();
			OOTVar<?> param = null;
			OOTAssign<OOTType> initialise = null;
			//System.out.println(var);
			if(getArg().type().equals(inttype.type())) {	  
				ootv = new OOTVar<OOTTypeInt>("public",var.name,new OOTTypeInt());
				
				//System.out.println(ootv.name);
				param = new OOTVar<OOTTypeInt>("public",var.name+String.valueOf(i),new OOTTypeInt());
				System.out.println(param.name);
				
				initialise = new OOTAssign<OOTType>(new OOTTypeNone(),(OOTVar<OOTType>) ootv,new OOTVarCall<OOTTypeInt>(new OOTVar<OOTTypeInt>("public",var.name+String.valueOf(i),new OOTTypeInt())));
				attributes.add(ootv);	
				//System.out.println(ootv);
				params.add(param);
				statements.add(initialise);
				i++;
			}	else if (getArg().type().equals(booltype.type())) {
				ootv = new OOTVar<OOTTypeBool>("public",var.name,new OOTTypeBool());
				param = new OOTVar<OOTTypeBool>("public",var.name+String.valueOf(i),new OOTTypeBool());
				initialise = new OOTAssign<OOTType>(new OOTTypeNone(),(OOTVar<OOTType>) ootv,new OOTVarCall<OOTTypeBool>(new OOTVar<OOTTypeBool>("public",var.name+String.valueOf(i),new OOTTypeBool())));
				//System.out.println(ootv);
				attributes.add(ootv);	
				params.add(param);
				statements.add(initialise);
				i++;
			} else if(var.position.type().equals(voidtype.type())) {
				if(jjtGetParent().toString() != "New") {
					String lc = jjtGetParent().toString(); 
					ASTTermVar f = (ASTTermVar)jjtGetParent().jjtGetChild(1);
					lc += f.getLineColumn();
					ootv = new OOTVar<OOTTypeClass>("public",var.name,new OOTTypeClass(lc));
					param = new OOTVar<OOTTypeClass>("public",var.name+String.valueOf(i),new OOTTypeClass(lc));
					initialise = new OOTAssign<OOTType>(new OOTTypeNone(),(OOTVar<OOTType>) ootv,new OOTVarCall<OOTTypeClass>(new OOTVar<OOTTypeClass>("public",var.name+String.valueOf(i),new OOTTypeClass(lc))));
					attributes.add(ootv);	
					params.add(param);
					statements.add(initialise);
					i++;
					//System.out.println("Var : "+var.name);
				}	
			}

		}

		OOTMeth<OOTType> construct = new OOTMeth<OOTType>("public",new OOTTypeNone(),name,params,statements);
		methods.add(construct);

		List<VarOccurrence> bound = this.declaredVars();
		List<OOTVar<?>> paramMethod = new ArrayList<OOTVar<?>>();

		OOTMeth<OOTType> meth = null;
		statements = new ArrayList<OOTStatement>();
		statements = getSecondProcess().code();
		Iterator<VarOccurrence> itBound = bound.iterator();
		while(itBound.hasNext()) {
			OOTVar<?> ootv=null;
			//System.out.println("Var : "+var.name);
			VarOccurrence var = itBound.next();
			//System.out.println("Var : "+var.name);
			if(var.position.type().equals(inttype.type())) {	  
				//System.out.println("Var : "+var.name);
				
				ootv = new OOTVar<OOTTypeInt>("public",var.name,new OOTTypeInt());
				paramMethod.add(ootv);
				System.out.println(getArgType()+" "+var.name+";");
				meth = new OOTMeth<OOTType>("public",new OOTTypeInt(),"val",paramMethod,statements);
				i++;
			}	else if (var.position.type().equals(booltype.type())) {
				ootv = new OOTVar<OOTTypeBool>("public",var.name,new OOTTypeBool());
				paramMethod.add(ootv);
				meth = new OOTMeth<OOTType>("public",new OOTTypeBool(),"val",paramMethod,statements);
				i++;
			}  else if(var.position.type().equals(voidtype.type())) {
				ootv = new OOTVar<OOTTypeVoid>("public",var.name,new OOTTypeVoid());
				//paramMethod.add(ootv);
				meth = new OOTMeth<OOTType>("public",new OOTTypeVoid(),"val",paramMethod,statements);
				i++;
			}	
		}	  
		methods.add(meth);

		OOTClass classe = new OOTClass(modifiers,name,"",generictypes,attributes,methods);
		classe.genCodeNode(name+".java");

		String paramMethC = "";
		Iterator<OOTVar<?>> itB = attributes.iterator();
		while(itB.hasNext()) {
			OOTVar<OOTTypeClass> var =  (OOTVar<OOTTypeClass>) itB.next();
			OOTVarCall<OOTTypeClass> vc = new OOTVarCall<OOTTypeClass>(var);
			paramMethC += var.genCodeNode("toto"); 
			ListeExpr.add(vc);
		}
		//OOTStatement state = new OOTClassNew(classe,ListeExpr);
		//listeRes.add(state);

		/* Initialisation de la liste de statement à renvoyer */

		OOTVar<OOTType> var =  new OOTVar<OOTType>("public",getArg().getName(),new OOTTypeClass(name));
		OOTStatement dec = new OOTVarCall<OOTType>(var);
		listeRes.add(dec);
		OOTAssign<OOTType> as = new OOTAssign<OOTType>(new OOTTypeClass(name),var,new OOTClassNew(classe,ListeExpr));
		listeRes.add(as);
		List<OOTVar<?>> liste = new ArrayList<OOTVar<?>>();
		liste.add(var);
		OOTMethCall methC = new OOTMethCall(liste,meth,ListeExpr);
		listeRes.add(methC);

		Iterator<OOTStatement> itState = listeRes.iterator();
		while(itState.hasNext()) {
			System.out.println(itState.next().genCodeState("toto.java"));
		}
		
		return listeRes;
	}
}
/* JavaCC - OriginalChecksum=3a817792e31aae3b01a6f89c0e971f0b (do not edit this line) */
