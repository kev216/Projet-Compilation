import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/* Generated By:JJTree: Do not edit this line. ASTSend.java Version 4.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTSend extends SimpleNode {
	public ASTSend(int id) {
		super(id);
	}

	public ASTSend(Parser p, int id) {
		super(p, id);
	}

	public Node getEnvoi() {return (Node)jjtGetChild(0);}
	public ASTTermVar getReceveur() {return (ASTTermVar)jjtGetChild(1);}

	public Type type() throws TypeException {
		Node t2 = (Node)jjtGetChild(1);
		ASTRef reftype = new ASTRef(ParserTreeConstants.JJTTYPE);
		if(!t2.type().equals(reftype.type()))
			throw new TypeException("Second process type is not Ref");
		ASTProc proctype = new ASTProc(ParserTreeConstants.JJTTYPE);
		return proctype.type();
	}  
	
	public void codeThread(String paramThread) throws TypeException {
		String modifiers = "public";
		//String name = "Thread"+getVar().getLineColumn()+" extends thread";
		String nameClass = "Thread"+getReceveur().getLineColumn();

		//Creation des differents parametres pour creer un objet OOTClass
		List<OOTVar<? extends OOTType>> attributes = new ArrayList<OOTVar<?>>();
		List<OOTVar<? extends OOTType>> params = new ArrayList<OOTVar<?>>();
		List<OOTType> generictypes = new ArrayList<OOTType>();
		List<OOTMeth<? extends OOTType>> methods = new ArrayList<OOTMeth<?>>();
		List<OOTStatement> statements = new ArrayList<OOTStatement>();


		//Types de reference
		ASTInt inttype = new ASTInt(Parser.JJTTYPE);
		ASTBool booltype = new ASTBool(Parser.JJTTYPE);
		ASTProc voidtype = new ASTProc(Parser.JJTTYPE);

		//Liste des variables libres
		VarOccurrence receveur = new VarOccurrence(getReceveur().getName(),getReceveur());
		List<VarOccurrence> bounds = new ArrayList<VarOccurrence>();
		bounds.add(receveur);
		List<VarOccurrence> free = this.findFreeBound(bounds);
		Iterator<VarOccurrence> itFree = free.iterator();
		int i=1;
		OOTVar<? extends OOTType> ootv=null;
		OOTVar<?> param = null;
		OOTAssign<OOTType> initialise = null;
		Node n = jjtGetParent();
		System.out.println("Le noeud est : "+jjtGetRootParent().toString());
		ASTTermVar x = (ASTTermVar)jjtGetRootParent().jjtGetChild(0);
		OOTVar<?> t = new OOTVar<OOTTypeClass>("public",getReceveur().getName(),new OOTTypeClass("Thread"+x.getLineColumn()));
		attributes.add(t);
		initialise = new OOTAssign<OOTType>(new OOTTypeNone(),(OOTVar<OOTType>) t,new OOTVarCall<OOTTypeClass>(new OOTVar<OOTTypeClass>("public",t.name+String.valueOf(i),new OOTTypeClass("Thread"+getReceveur().getLineColumn()))));
		statements.add(initialise);
		param = new OOTVar<OOTTypeClass>("public",t.name+String.valueOf(i),new OOTTypeClass("Thread"+x.getLineColumn()));
		params.add(param);
		OOTVar<OOTType> liste = new OOTVar<OOTType>("public","l",new OOTTypeClass("ArrayBlockingQueue"));
		OOTClass blockQueue = new OOTClass("public","ArrayBlockingQueue","",new ArrayList<OOTType>(),new ArrayList<OOTVar<?>>(),new ArrayList<OOTMeth<?>>());
		OOTAssign<OOTType> initListe = new OOTAssign<OOTType>(new OOTTypeNone(),(OOTVar<OOTType>) liste,new OOTClassNew(blockQueue,new ArrayList<OOTExpr<? extends OOTType>>()));
		statements.add(initListe);
		while(itFree.hasNext()) {
			VarOccurrence var = itFree.next();
			//System.out.println("Var : "+var.name);
			if(var.position.type().equals(inttype.type())) {	  
				ootv = new OOTVar<OOTTypeInt>("public",var.name,new OOTTypeInt());
				param = new OOTVar<OOTTypeInt>("public",var.name+String.valueOf(i),new OOTTypeInt());
				initialise = new OOTAssign<OOTType>(new OOTTypeNone(),(OOTVar<OOTType>) ootv,new OOTVarCall<OOTTypeInt>(new OOTVar<OOTTypeInt>("public",var.name+String.valueOf(i),new OOTTypeInt())));
				attributes.add(ootv);	
				params.add(param);
				statements.add(initialise);
				i++;
			/*} else if (var.position.type().equals(booltype.type())) {
				ootv = new OOTVar<OOTTypeBool>("public",var.name,new OOTTypeBool());
				param = new OOTVar<OOTTypeBool>("public",var.name+String.valueOf(i),new OOTTypeBool());
				initialise = new OOTAssign<OOTType>(new OOTTypeNone(),(OOTVar<OOTType>) ootv,new OOTVarCall<OOTTypeBool>(new OOTVar<OOTTypeBool>("public",var.name+String.valueOf(i),new OOTTypeBool())));
				attributes.add(ootv);	
				params.add(param);
				statements.add(initialise);
				i++;*/
			}  else if(var.position.type().equals(voidtype.type())) {
				String lc = jjtGetParent().toString(); 
				ASTTermVar f = (ASTTermVar)jjtGetParent().jjtGetChild(1);
				lc += f.getLineColumn();
				ootv = new OOTVar<OOTTypeClass>("public",var.name,new OOTTypeClass(lc));
				param = new OOTVar<OOTTypeClass>("public",var.name+String.valueOf(i),new OOTTypeClass(lc));
				initialise = new OOTAssign<OOTType>(new OOTTypeNone(),(OOTVar<OOTType>) ootv,new OOTVarCall<OOTTypeClass>(new OOTVar<OOTTypeClass>("public",var.name+String.valueOf(i),new OOTTypeClass(lc))));
				attributes.add(ootv);	
				params.add(param);
				statements.add(initialise);
				i++;
			}
			
		}
		attributes.add(liste);
		
		OOTMeth<OOTType> construct = new OOTMeth<OOTType>("public",new OOTTypeNone(),nameClass,params,statements);
		methods.add(construct);
		List<OOTVar<? extends OOTType>> listeAppelante = new ArrayList<OOTVar<? extends OOTType>>();
		OOTVar<?> recev = t;
		listeAppelante.add(recev);
		listeAppelante.add(liste);
		OOTMethConnu runConnu = new OOTMethConnu(listeAppelante,"add",paramThread);
		statements = new ArrayList<OOTStatement>();
		statements.add(runConnu);
		OOTMeth<OOTType> run = new OOTMeth<OOTType>("public",new OOTTypeVoid(),"run",new ArrayList<OOTVar<? extends OOTType>>(),statements); 
		methods.add(run);
		
		OOTClass classe = new OOTClass(modifiers,nameClass,"thread",generictypes,attributes,methods);
		classe.genCodeNode(nameClass+".java");
	}

	public List<OOTStatement> code() throws TypeException {
		List<OOTStatement> listeRes = new ArrayList<OOTStatement>();
		String modifiers = "public";
		String name = "Send"+this.id;

		//Creation des differents parametres pour creer un objet OOTClass
		List<OOTVar<? extends OOTType>> attributes = new ArrayList<OOTVar<?>>();
		List<OOTVar<? extends OOTType>> params = new ArrayList<OOTVar<?>>();
		List<OOTType> generictypes = new ArrayList<OOTType>();
		List<OOTMeth<? extends OOTType>> methods = new ArrayList<OOTMeth<?>>();
		List<OOTStatement> statements = new ArrayList<OOTStatement>();

		List<OOTExpr<?>> ListeExpr = new ArrayList<OOTExpr<?>>(); 

		//Types de reference
		ASTInt inttype = new ASTInt(Parser.JJTTYPE);
		ASTBool booltype = new ASTBool(Parser.JJTTYPE);
		ASTProc voidtype = new ASTProc(Parser.JJTTYPE);


		//Liste des variables libres
		List<VarOccurrence> free = this.findFreeBound(new ArrayList<VarOccurrence>());
		Iterator<VarOccurrence> itFree = free.iterator();
		int i=1;
		while(itFree.hasNext()) {
			OOTVar<?> ootv=null;
			VarOccurrence var = itFree.next();
			OOTVar<?> param = null;
			OOTAssign<OOTType> initialise = null;
			if(var.position.type().equals(inttype.type())) {	  
				ootv = new OOTVar<OOTTypeInt>("public",var.name,new OOTTypeInt());
				attributes.add(ootv);
				param = new OOTVar<OOTTypeInt>("public",var.name+String.valueOf(i),new OOTTypeInt());
				params.add(param);
				initialise = new OOTAssign<OOTType>(new OOTTypeNone(),(OOTVar<OOTType>) ootv,new OOTVarCall<OOTTypeInt>(new OOTVar<OOTTypeInt>("public",var.name+String.valueOf(i),new OOTTypeInt())));
				statements.add(initialise);
				i++;
			}	else if (var.position.type().equals(booltype.type())) {
				ootv = new OOTVar<OOTTypeBool>("public",var.name,new OOTTypeBool());
				attributes.add(ootv);
				param = new OOTVar<OOTTypeBool>("public",var.name+String.valueOf(i),new OOTTypeBool());
				params.add(param);
				initialise = new OOTAssign<OOTType>(new OOTTypeNone(),(OOTVar<OOTType>) ootv,new OOTVarCall<OOTTypeBool>(new OOTVar<OOTTypeBool>("public",var.name+String.valueOf(i),new OOTTypeBool())));
				statements.add(initialise);
				i++;
			}  else if(var.position.type().equals(voidtype.type())) {
				String lc = jjtGetParent().toString(); 
				ASTTermVar f = (ASTTermVar)jjtGetParent().jjtGetChild(1);
				lc += f.getLineColumn();
				ootv = new OOTVar<OOTTypeClass>("public",var.name,new OOTTypeClass(lc));
				param = new OOTVar<OOTTypeClass>("public",var.name+String.valueOf(i),new OOTTypeClass(lc));
				initialise = new OOTAssign<OOTType>(new OOTTypeNone(),(OOTVar<OOTType>) ootv,new OOTVarCall<OOTTypeClass>(new OOTVar<OOTTypeClass>("public",var.name+String.valueOf(i),new OOTTypeClass(lc))));
				attributes.add(ootv);	
				params.add(param);
				statements.add(initialise);
				i++;
			}
			
		}

		OOTMeth<OOTType> construct = new OOTMeth<OOTType>("public",new OOTTypeNone(),name,params,statements);
		methods.add(construct);

		List<OOTVar<?>> paramMethod = new ArrayList<OOTVar<?>>();

		OOTMeth<OOTType> meth = null;
		statements = new ArrayList<OOTStatement>();
		Node n = getEnvoi();
		statements = getEnvoi().code();
		meth = new OOTMeth<OOTType>("public",new OOTTypeInt(),"val",paramMethod,statements);
		methods.add(meth);

		OOTClass classe = new OOTClass(modifiers,name,"",generictypes,attributes,methods);
		classe.genCodeNode(name+".java");

		Iterator<OOTVar<?>> itB = attributes.iterator();
		while(itB.hasNext()) {
			OOTVar<OOTTypeClass> var =  (OOTVar<OOTTypeClass>) itB.next();
			OOTVarCall<OOTTypeClass> vc = new OOTVarCall<OOTTypeClass>(var);
			ListeExpr.add(vc);
		}
		OOTStatement state = new OOTClassNew(classe,ListeExpr);
		listeRes.add(state);

		/*Iterator<OOTStatement> itState = listeRes.iterator();
		while(itState.hasNext()) {
			System.out.println(itState.next().genCodeState("toto.java"));
		}*/
		this.codeThread(listeRes.get(0).genCodeNode("toto.java"));
		return listeRes;
	}

}

/* JavaCC - OriginalChecksum=0163c6c071e0c7986686cde3bc71040e (do not edit this line) */
